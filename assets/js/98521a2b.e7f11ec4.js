"use strict";(self.webpackChunkdocs_new=self.webpackChunkdocs_new||[]).push([[87],{7747:(e,o,n)=>{n.r(o),n.d(o,{assets:()=>l,contentTitle:()=>r,default:()=>p,frontMatter:()=>c,metadata:()=>i,toc:()=>a});const i=JSON.parse('{"id":"concepts/policies","title":"Policies","description":"Policies define which nodes in a drasyl network are allowed to communicate. These policies are enforced on both endpoints.","source":"@site/docs/concepts/policies.md","sourceDirName":"concepts","slug":"/concepts/policies","permalink":"/concepts/policies","draft":false,"unlisted":false,"editUrl":"https://github.com/drasyl/docs.drasyl.org/blob/master/docs/concepts/policies.md","tags":[],"version":"current","lastUpdatedAt":1753913631000,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Nodes","permalink":"/concepts/nodes"},"next":{"title":"Routes","permalink":"/concepts/routes"}}');var t=n(4848),s=n(8453);const c={},r="Policies",l={},a=[{value:"Concept",id:"concept",level:2},{value:"Policy Attributes",id:"policy-attributes",level:2},{value:"<code>source_groups</code>",id:"source_groups",level:3},{value:"<code>destination_groups</code>",id:"destination_groups",level:3},{value:"Example Policy Configuration",id:"example-policy-configuration",level:2}];function d(e){const o={admonition:"admonition",br:"br",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",p:"p",pre:"pre",...(0,s.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(o.header,{children:(0,t.jsx)(o.h1,{id:"policies",children:"Policies"})}),"\n",(0,t.jsx)(o.p,{children:"Policies define which nodes in a drasyl network are allowed to communicate. These policies are enforced on both endpoints."}),"\n",(0,t.jsx)(o.h2,{id:"concept",children:"Concept"}),"\n",(0,t.jsxs)(o.p,{children:["Each policy rule defines communication permissions between groups of nodes.",(0,t.jsx)(o.br,{}),"\n","Although policies are written in a unidirectional format with ",(0,t.jsx)(o.code,{children:"source_groups"})," and ",(0,t.jsx)(o.code,{children:"destination_groups"}),",\nthey are currently evaluated symmetrically: if group A can contact group B, group B can also contact group A."]}),"\n",(0,t.jsx)(o.admonition,{title:"Directional format",type:"info",children:(0,t.jsxs)(o.p,{children:["The directional structure (",(0,t.jsx)(o.code,{children:"source_groups"})," \u2192 ",(0,t.jsx)(o.code,{children:"destination_groups"}),") was chosen intentionally to support future extensions.",(0,t.jsx)(o.br,{}),"\n","We plan to support unidirectional policies, where only the defined direction will be allowed."]})}),"\n",(0,t.jsx)(o.p,{children:"drasyl follows a default-deny approach: Without a matching policy, no communication between nodes is possible, even if they are in the same group. All communication must be explicitly granted via policy configuration."}),"\n",(0,t.jsx)(o.h2,{id:"policy-attributes",children:"Policy Attributes"}),"\n",(0,t.jsx)(o.p,{children:"Each policy entry must include the following fields:"}),"\n",(0,t.jsx)(o.h3,{id:"source_groups",children:(0,t.jsx)(o.code,{children:"source_groups"})}),"\n",(0,t.jsxs)(o.p,{children:["A list of node groups that are allowed to initiate communication.",(0,t.jsx)(o.br,{}),"\n","Each group name must match one defined in the node configuration.",(0,t.jsx)(o.br,{}),"\n","Use ",(0,t.jsx)(o.code,{children:"ALL"})," to refer to all nodes in the network."]}),"\n",(0,t.jsx)(o.admonition,{title:"Directional format",type:"info",children:(0,t.jsxs)(o.p,{children:["Although policies are currently evaluated symmetrically, the ",(0,t.jsx)(o.code,{children:"source_groups"})," field indicates the intended direction of communication and prepares for future support of unidirectional rules."]})}),"\n",(0,t.jsx)(o.h3,{id:"destination_groups",children:(0,t.jsx)(o.code,{children:"destination_groups"})}),"\n",(0,t.jsxs)(o.p,{children:["A list of node groups that may be contacted by the source groups.",(0,t.jsx)(o.br,{}),"\n","Each group name must also match one defined in the node configuration.",(0,t.jsx)(o.br,{}),"\n","Use ",(0,t.jsx)(o.code,{children:"ALL"})," to refer to all nodes in the network."]}),"\n",(0,t.jsx)(o.admonition,{title:"Directional format",type:"info",children:(0,t.jsxs)(o.p,{children:["This field defines the target of a communication rule. Together with ",(0,t.jsx)(o.code,{children:"source_groups"}),", it forms a directional policy that is, for now, applied symmetrically."]})}),"\n",(0,t.jsx)(o.h2,{id:"example-policy-configuration",children:"Example Policy Configuration"}),"\n",(0,t.jsx)(o.p,{children:"Here is an example of a policy entry in a TOML configuration file:"}),"\n",(0,t.jsx)(o.pre,{children:(0,t.jsx)(o.code,{className:"language-toml",children:'[[policy]]\nsource_groups      = ["notebooks"]\ndestination_groups = ["desktops"]\n'})})]})}function p(e={}){const{wrapper:o}={...(0,s.R)(),...e.components};return o?(0,t.jsx)(o,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},8453:(e,o,n)=>{n.d(o,{R:()=>c,x:()=>r});var i=n(6540);const t={},s=i.createContext(t);function c(e){const o=i.useContext(s);return i.useMemo(function(){return"function"==typeof e?e(o):{...o,...e}},[o,e])}function r(e){let o;return o=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:c(e.components),i.createElement(s.Provider,{value:o},e.children)}}}]);